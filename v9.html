
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SVG Whiteboard</title>
<style>
  body, html { margin:0; padding:0; height:100%; overflow:hidden; }
  #toolbar {
    position: fixed; top: 10px; left: 10px; background: rgba(255,255,255,0.9);
    padding: 8px; border-radius: 6px; display: flex; gap: 8px; z-index: 10;
  }
  #whiteboard { width:100%; height:100%; touch-action:none; }
  input[type="color"], input[type="range"], button { font-size:16px; }
</style>
</head>
<body>
<div id="toolbar">
  <input type="color" id="colorPicker" value="#000000">
  <input type="range" id="strokeWidth" min="1" max="20" value="3">
  <button id="eraseBtn">Erase: OFF</button>
  <button id="openSVG">Open SVG</button>
  <button id="saveSVG">Save SVG</button>
  <button id="savePNG">Save PNG</button>
  <input type="file" id="fileInput" accept=".svg" style="display:none;">
</div>

<svg id="whiteboard" xmlns="http://www.w3.org/2000/svg">
  <g id="boardContent"></g>
</svg>

<script>
const svg = document.getElementById('whiteboard');
const content = document.getElementById('boardContent');
let drawing = false, eraseMode = false;
let currentPath = null;
let color = document.getElementById('colorPicker').value;
let strokeWidth = document.getElementById('strokeWidth').value;
let viewBox = { x:0, y:0, w:window.innerWidth, h:window.innerHeight };
svg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);

let lastTouches = [];
let scale = 1;

// Update color and stroke
document.getElementById('colorPicker').oninput = e => color = e.target.value;
document.getElementById('strokeWidth').oninput = e => strokeWidth = e.target.value;

// Erase toggle
document.getElementById('eraseBtn').onclick = () => {
  eraseMode = !eraseMode;
  document.getElementById('eraseBtn').textContent = `Erase: ${eraseMode ? 'ON' : 'OFF'}`;
};

// Handle drawing
function getSVGCoords(clientX, clientY) {
  const rect = svg.getBoundingClientRect();
  const x = viewBox.x + (clientX - rect.left) * (viewBox.w / rect.width);
  const y = viewBox.y + (clientY - rect.top) * (viewBox.h / rect.height);
  return {x,y};
}

function startDraw(x,y) {
  if (eraseMode) return;
  drawing = true;
  currentPath = document.createElementNS('http://www.w3.org/2000/svg','path');
  currentPath.setAttribute('d', `M ${x} ${y}`);
  currentPath.setAttribute('stroke', color);
  currentPath.setAttribute('stroke-width', strokeWidth);
  currentPath.setAttribute('fill','none');
  currentPath.setAttribute('stroke-linecap','round');
  currentPath.setAttribute('stroke-linejoin','round');
  content.appendChild(currentPath);
}

function draw(x,y) {
  if (!drawing || eraseMode) return;
  let d = currentPath.getAttribute('d');
  currentPath.setAttribute('d', `${d} L ${x} ${y}`);
}

function endDraw() { drawing = false; currentPath = null; }

// Erase logic
function eraseAt(x,y) {
  const pt = getSVGCoords(x,y);
  const paths = Array.from(content.querySelectorAll('path'));
  paths.forEach(p => {
    const d = p.getAttribute('d');
    if (d.includes(`${Math.round(pt.x)}`) || d.includes(`${Math.round(pt.y)}`)) {
      p.remove();
    }
  });
}

// Mouse/touch events
svg.addEventListener('pointerdown', e => {
  if (e.pointerType === 'touch' && lastTouches.length === 1) return; // multi-touch handled separately
  const pt = getSVGCoords(e.clientX,e.clientY);
  if (eraseMode) eraseAt(e.clientX,e.clientY);
  else startDraw(pt.x,pt.y);
});
svg.addEventListener('pointermove', e => {
  if (drawing && !eraseMode) {
    const pt = getSVGCoords(e.clientX,e.clientY);
    draw(pt.x,pt.y);
  }
});
svg.addEventListener('pointerup', endDraw);
svg.addEventListener('pointercancel', endDraw);

// Multi-touch pan/zoom
svg.addEventListener('touchstart', e => {
  if (e.touches.length > 1) {
    lastTouches = [...e.touches];
  }
});
svg.addEventListener('touchmove', e => {
  if (e.touches.length > 1 && lastTouches.length > 1) {
    const dx = (e.touches[0].clientX - lastTouches[0].clientX);
    const dy = (e.touches[0].clientY - lastTouches[0].clientY);
    viewBox.x -= dx * (viewBox.w / svg.clientWidth);
    viewBox.y -= dy * (viewBox.h / svg.clientHeight);

    const distOld = Math.hypot(
      lastTouches[0].clientX - lastTouches[1].clientX,
      lastTouches[0].clientY - lastTouches[1].clientY
    );
    const distNew = Math.hypot(
      e.touches[0].clientX - e.touches[1].clientX,
      e.touches[0].clientY - e.touches[1].clientY
    );
    const zoomFactor = distNew / distOld;
    viewBox.w /= zoomFactor;
    viewBox.h /= zoomFactor;

    svg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
    lastTouches = [...e.touches];
  }
});

// Resize
window.addEventListener('resize', () => {
  viewBox.w = window.innerWidth;
  viewBox.h = window.innerHeight;
  svg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
});

// Open SVG
document.getElementById('openSVG').onclick = () => document.getElementById('fileInput').click();
document.getElementById('fileInput').onchange = e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = evt => {
    content.innerHTML = new DOMParser().parseFromString(evt.target.result,'image/svg+xml').querySelector('g').innerHTML;
  };
  reader.readAsText(file);
};

// Save SVG
document.getElementById('saveSVG').onclick = () => {
  const blob = new Blob([svg.outerHTML], {type:'image/svg+xml'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'whiteboard.svg';
  a.click();
};

// Save PNG
document.getElementById('savePNG').onclick = () => {
  const xml = new XMLSerializer().serializeToString(svg);
  const img = new Image();
  img.onload = () => {
    const canvas = document.createElement('canvas');
    canvas.width = svg.clientWidth;
    canvas.height = svg.clientHeight;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(img,0,0);
    canvas.toBlob(blob => {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'whiteboard.png';
      a.click();
    }, 'image/png');
  };
  img.src = 'data:image/svg+xml;base64,' + btoa(xml);
};
</script>
</body>
</html>
