
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>SVG Whiteboard â€” Draw / Pan / Erase</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1.0" />
  <style>
    :root {
      color-scheme: light;
      --ui-bg: #f7f7f8;
      --ui-border: #d0d7de;
      --ui-text: #222;
      --btn-bg: #fff;
      --btn-act: #006aff;
      --btn-text: #111;
    }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #ffffff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
      -webkit-user-select: none;
      user-select: none;
      overscroll-behavior: none; /* prevent rubber-banding on iOS */
    }

    #toolbar {
      position: fixed;
      top: 8px;
      left: 8px;
      right: 8px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      padding: 8px 10px;
      background: var(--ui-bg);
      border: 1px solid var(--ui-border);
      border-radius: 10px;
      z-index: 9999;
      box-shadow: 0 4px 20px rgba(0,0,0,0.08);
    }

    #toolbar .group {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      padding-right: 4px;
      border-right: 1px solid var(--ui-border);
    }
    #toolbar .group:last-child { border-right: none; }

    button, label {
      padding: 6px 10px;
      background: var(--btn-bg);
      border: 1px solid var(--ui-border);
      border-radius: 8px;
      color: var(--btn-text);
      cursor: pointer;
      font-size: 14px;
    }
    button.active {
      border-color: var(--btn-act);
      color: var(--btn-act);
      font-weight: 600;
    }
    input[type="range"] { width: 120px; }

    #status {
      margin-left: auto;
      font-size: 12px;
      color: #444;
    }

    /* SVG fills the window and uses custom gestures */
    #board {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      background: #fff;
      touch-action: none; /* we implement our own gestures */
      cursor: crosshair;
    }

    /* Active mode cursors */
    #board.mode-pan { cursor: grab; }
    #board.mode-pan.dragging { cursor: grabbing; }
    #board.mode-erase { cursor: cell; }

    /* Make strokes hit-testable with pointer-events: stroke */
    #content path, #content polyline, #content line {
      pointer-events: stroke;
    }

    /* Eraser marker (overlay) */
    #overlay circle.eraser {
      fill: rgba(255,0,0,0.08);
      stroke: rgba(255,0,0,0.35);
      stroke-width: 1;
      vector-effect: non-scaling-stroke;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <div class="group">
      <input id="openFile" type="file" accept=".svg,image/svg+xml" />
      <button id="saveSvg">Save SVG</button>
    </div>
    <div class="group">
      <label>Color <input id="color" type="color" value="#1f1f1f"></label>
      <label>Width <input id="width" type="range" min="1" max="50" step="1" value="5"></label>
      <span id="widthVal">5 px</span>
    </div>
    <div class="group">
      <button id="modeDraw" class="active">Draw</button>
      <button id="modePan">Pan</button>
      <button id="modeErase">Erase</button>
    </div>
    <div id="status">Zoom: 100%</div>
  </div>

  <!-- SVG Whiteboard -->
  <svg id="board" xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       viewBox="0 0 1000 1000" preserveAspectRatio="none">
    <g id="content"></g>
    <g id="overlay"></g>
  </svg>

  <script>
  (() => {
    const ns = "http://www.w3.org/2000/svg";
    const svg = document.getElementById('board');
    const content = document.getElementById('content');
    const overlay = document.getElementById('overlay');

    const openFile = document.getElementById('openFile');
    const saveBtn = document.getElementById('saveSvg');
    const colorInput = document.getElementById('color');
    const widthInput = document.getElementById('width');
    const widthVal = document.getElementById('widthVal');
    const modeDrawBtn = document.getElementById('modeDraw');
    const modePanBtn  = document.getElementById('modePan');
    const modeEraseBtn= document.getElementById('modeErase');
    const statusEl = document.getElementById('status');

    // ----- State -----
    let mode = 'draw'; // 'draw' | 'pan' | 'erase'
    let drawingByPointer = new Map(); // pointerId -> { path, lastSVG }
    let activePointers = new Map();   // pointerId -> { lastScreen, lastSVG }
    let viewBox = { x:0, y:0, w:1000, h:1000 };

    // Cached pixel scale (SVG units per screen pixel)
    let pxScaleX = viewBox.w / svg.clientWidth;
    let pxScaleY = viewBox.h / svg.clientHeight;

    // Pinch state (robust on iOS)
    let pinch = null; // { id1, id2, vbox0, pxScaleX0, pxScaleY0, midScreen0, distScreen0, anchorSVG }

    widthVal.textContent = `${widthInput.value} px`;

    // ----- Helpers -----
    function updateStatus() {
      const zoomPct = (1000 / viewBox.w) * 100; // baseline is w=1000 => 100%
      statusEl.textContent = `Zoom: ${zoomPct.toFixed(0)}%`;
    }

    function setMode(newMode) {
      mode = newMode;
      modeDrawBtn.classList.toggle('active', mode === 'draw');
      modePanBtn.classList.toggle('active',  mode === 'pan');
      modeEraseBtn.classList.toggle('active',mode === 'erase');

      svg.classList.toggle('mode-pan', mode === 'pan');
      svg.classList.toggle('mode-erase', mode === 'erase');
    }

    function applyViewBox() {
      svg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
      // update scale cache
      pxScaleX = viewBox.w / svg.clientWidth;
      pxScaleY = viewBox.h / svg.clientHeight;
      updateStatus();
    }

    function screenToSVG(x, y) {
      const pt = svg.createSVGPoint();
      pt.x = x; pt.y = y;
      return pt.matrixTransform(svg.getScreenCTM().inverse());
    }

    function anchoredZoom(anchorSVG, scaleFactor, vbox = viewBox) {
      const fX = (anchorSVG.x - vbox.x) / vbox.w;
      const fY = (anchorSVG.y - vbox.y) / vbox.h;
      const newW = vbox.w / scaleFactor;
      const newH = vbox.h / scaleFactor;
      const newX = anchorSVG.x - fX * newW;
      const newY = anchorSVG.y - fY * newH;
      return { x:newX, y:newY, w:newW, h:newH };
    }

    function makePath(startSVG) {
      const p = document.createElementNS(ns, 'path');
      p.setAttribute('d', `M ${startSVG.x} ${startSVG.y}`);
      p.setAttribute('fill', 'none');
      p.setAttribute('stroke', colorInput.value);
      p.setAttribute('stroke-width', widthInput.value);
      p.setAttribute('stroke-linecap', 'round');
      p.setAttribute('stroke-linejoin', 'round');
      p.setAttribute('vector-effect', 'non-scaling-stroke'); // keep width consistent visually
      p.style.pointerEvents = 'stroke';
      return p;
    }

    function appendLineToPath(path, svgPt) {
      const d = path.getAttribute('d');
      path.setAttribute('d', d + ` L ${svgPt.x} ${svgPt.y}`);
    }

    function length2(a, b) {
      const dx = a.x - b.x, dy = a.y - b.y;
      return Math.sqrt(dx*dx + dy*dy);
    }

    function eraseAtScreenPoint(sx, sy) {
      const stack = document.elementsFromPoint(sx, sy);
      for (const el of stack) {
        if (!el || !(el instanceof Element)) continue;
        if (el.parentElement && el.parentElement.id === 'content' &&
            (el.tagName === 'path' || el.tagName === 'polyline' || el.tagName === 'line')) {
          el.remove();
          return true;
        }
      }
      return false;
    }

    function showEraser(svgPt, radiusSVG = Math.max(8, viewBox.w / 150)) {
      let er = overlay.querySelector('circle.eraser');
      if (!er) {
        er = document.createElementNS(ns, 'circle');
        er.classList.add('eraser');
        overlay.appendChild(er);
      }
      er.setAttribute('cx', svgPt.x);
      er.setAttribute('cy', svgPt.y);
      er.setAttribute('r', radiusSVG);
    }
    function hideEraser() {
      const er = overlay.querySelector('circle.eraser');
      if (er) er.remove();
    }

    // ----- Open SVG -----
    openFile.addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      const text = await file.text();
      const parser = new DOMParser();
      const doc = parser.parseFromString(text, 'image/svg+xml');

      const root = doc.documentElement;
      content.innerHTML = '';
      let nodesToImport = [];

      if (root.tagName.toLowerCase() === 'svg') {
        const vb = root.getAttribute('viewBox');
        if (vb) {
          const [x,y,w,h] = vb.split(/[ ,]+/).map(Number);
          if ([x,y,w,h].every(n => Number.isFinite(n))) {
            viewBox = { x, y, w, h };
            applyViewBox();
          }
        }
        nodesToImport = Array.from(root.childNodes);
      } else {
        nodesToImport = Array.from(doc.childNodes);
      }

      for (const node of nodesToImport) {
        if (node.nodeType === 1 /*Element*/) {
          const imported = document.importNode(node, true);
          if (imported.tagName.toLowerCase() === 'svg') {
            Array.from(imported.childNodes).forEach(ch => {
              if (ch.nodeType === 1) content.appendChild(ch);
            });
          } else {
            content.appendChild(imported);
          }
        }
      }
    });

    // ----- Save SVG -----
    function serializeDrawingAsSVG() {
      const tmp = document.createElementNS(ns, 'svg');
      tmp.setAttribute('xmlns', ns);
      tmp.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
      tmp.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
      tmp.setAttribute('width', '1000');
      tmp.setAttribute('height', '1000');
      tmp.setAttribute('preserveAspectRatio', 'xMidYMid meet');

      const exportContent = content.cloneNode(true);
      exportContent.id = 'content';
      tmp.appendChild(exportContent);

      const style = document.createElementNS(ns, 'style');
      style.textContent = `
        #content path, #content polyline, #content line {
          pointer-events: stroke;
        }
      `;
      tmp.appendChild(style);

      const serializer = new XMLSerializer();
      return serializer.serializeToString(tmp);
    }

    saveBtn.addEventListener('click', () => {
      const svgText = serializeDrawingAsSVG();
      const blob = new Blob([svgText], { type: 'image/svg+xml' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `whiteboard-${Date.now()}.svg`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(a.href);
    });

    // ----- Toolbar -----
    widthInput.addEventListener('input', () => {
      widthVal.textContent = `${widthInput.value} px`;
    });

    modeDrawBtn.addEventListener('click', () => setMode('draw'));
    modePanBtn.addEventListener('click',  () => setMode('pan'));
    modeEraseBtn.addEventListener('click',() => setMode('erase'));

    // ----- Pointer handlers -----
    function onPointerDown(e) {
      e.preventDefault();

      // Capture only the first pointer to avoid iOS jumpiness
      if (activePointers.size === 0) {
        try { svg.setPointerCapture(e.pointerId); } catch {}
      }

      const screenPt = { x: e.clientX, y: e.clientY };
      const svgPt = screenToSVG(e.clientX, e.clientY);
      activePointers.set(e.pointerId, { lastScreen: screenPt, lastSVG: svgPt });

      // Two-finger pinch zoom (mobile): robust with frozen frame
      if (activePointers.size === 2 && !pinch) {
        const ids = Array.from(activePointers.keys());
        const s1 = activePointers.get(ids[0]).lastScreen;
        const s2 = activePointers.get(ids[1]).lastScreen;
        const p1 = activePointers.get(ids[0]).lastSVG;
        const p2 = activePointers.get(ids[1]).lastSVG;

        pinch = {
          id1: ids[0], id2: ids[1],
          vbox0: { ...viewBox },
          pxScaleX0: viewBox.w / svg.clientWidth,
          pxScaleY0: viewBox.h / svg.clientHeight,
          midScreen0: { x: (s1.x+s2.x)/2, y: (s1.y+s2.y)/2 },
          distScreen0: Math.hypot(s1.x - s2.x, s1.y - s2.y),
          anchorSVG: { x: (p1.x+p2.x)/2, y: (p1.y+p2.y)/2 }
        };
        hideEraser();
        return;
      }

      // Draw mode
      if (mode === 'draw' && activePointers.size === 1) {
        const path = makePath(svgPt);
        content.appendChild(path);
        drawingByPointer.set(e.pointerId, { path, lastSVG: svgPt });
      }

      // Pan mode
      if (mode === 'pan' && activePointers.size === 1) {
        svg.classList.add('dragging');
      }

      // Erase mode
      if (mode === 'erase') {
        showEraser(svgPt);
        eraseAtScreenPoint(e.clientX, e.clientY);
      }
    }

    function onPointerMove(e) {
      if (!activePointers.has(e.pointerId)) return;

      const events = e.getCoalescedEvents ? e.getCoalescedEvents() : [e];

      for (const ev of events) {
        ev.preventDefault();

        const prev = activePointers.get(e.pointerId);
        const screenPt = { x: ev.clientX, y: ev.clientY };
        const svgPt    = screenToSVG(ev.clientX, ev.clientY);
        activePointers.set(e.pointerId, { lastScreen: screenPt, lastSVG: svgPt });

        // ----- Pinch zoom (stable on iOS) -----
        if (pinch && activePointers.size === 2) {
          const s1 = activePointers.get(pinch.id1)?.lastScreen;
          const s2 = activePointers.get(pinch.id2)?.lastScreen;
          if (s1 && s2) {
            const midNow = { x: (s1.x+s2.x)/2, y: (s1.y+s2.y)/2 };
            const distNow = Math.hypot(s1.x - s2.x, s1.y - s2.y);

            // scale from screen distance ratio (avoid changing inverses mid-gesture)
            let scale = distNow / pinch.distScreen0;
            // clamp extremes to avoid wild jumps
            scale = Math.max(0.05, Math.min(20, scale));

            // zoom around the fixed SVG anchor using the initial viewBox
            const targetVB = anchoredZoom(pinch.anchorSVG, scale, pinch.vbox0);

            // translate by screen midpoint drift, mapped using initial pixel scale
            const dxScreen = midNow.x - pinch.midScreen0.x;
            const dyScreen = midNow.y - pinch.midScreen0.y;
            targetVB.x -= dxScreen * pinch.pxScaleX0;
            targetVB.y -= dyScreen * pinch.pxScaleY0;

            // Apply directly (or use mild smoothing if desired)
            viewBox = targetVB;
            applyViewBox();
          }
          continue;
        }

        // ----- Draw mode -----
        if (mode === 'draw') {
          const dra = drawingByPointer.get(e.pointerId);
          if (dra) {
            const dist = Math.hypot(dra.lastSVG.x - svgPt.x, dra.lastSVG.y - svgPt.y);
            const minSeg = viewBox.w / 1000; // adapt threshold with zoom
            if (dist >= minSeg) {
              appendLineToPath(dra.path, svgPt);
              dra.lastSVG = svgPt;
            }
          }
          continue;
        }

        // ----- Pan mode (fast: use screen deltas -> SVG units) -----
        if (mode === 'pan' && activePointers.size === 1) {
          const dxScreen = screenPt.x - prev.lastScreen.x;
          const dyScreen = screenPt.y - prev.lastScreen.y;

          viewBox.x -= dxScreen * pxScaleX;
          viewBox.y -= dyScreen * pxScaleY;
          applyViewBox();
          continue;
        }

        // ----- Erase mode -----
        if (mode === 'erase') {
          showEraser(svgPt);
          const last = prev.lastScreen;
          const cur  = screenPt;
          const dx = cur.x - last.x;
          const dy = cur.y - last.y;
          const steps = Math.max(1, Math.ceil(Math.hypot(dx, dy) / 12)); // ~12px sampling
          for (let i=0;i<=steps;i++) {
            const sx = last.x + dx * (i/steps);
            const sy = last.y + dy * (i/steps);
            eraseAtScreenPoint(sx, sy);
          }
          continue;
        }
      }
    }

    function onPointerUpOrCancel(e) {
      e.preventDefault();

      // End pinch when a finger lifts
      if (pinch && (e.pointerId === pinch.id1 || e.pointerId === pinch.id2)) {
        pinch = null;
      }

      // Finish drawing
      const dra = drawingByPointer.get(e.pointerId);
      if (dra) {
        const d = dra.path.getAttribute('d');
        if (/^M\s+([^\s]+)\s+([^\s]+)$/.test(d)) {
          const m = d.match(/^M\s+([^\s]+)\s+([^\s]+)$/);
          if (m) {
            const x = parseFloat(m[1]), y = parseFloat(m[2]);
            const tiny = 0.0001 * viewBox.w;
            dra.path.setAttribute('d', `M ${x} ${y} L ${x + tiny} ${y}`);
          }
        }
        drawingByPointer.delete(e.pointerId);
      }

      activePointers.delete(e.pointerId);

      if (mode === 'pan') svg.classList.remove('dragging');
      if (mode === 'erase' && activePointers.size === 0) hideEraser();

      // Release capture when no pointers remain
      if (activePointers.size === 0) {
        try { svg.releasePointerCapture(e.pointerId); } catch {}
      }
    }

    svg.addEventListener('pointerdown', onPointerDown, { passive: false });
    svg.addEventListener('pointermove', onPointerMove, { passive: false });
    svg.addEventListener('pointerup', onPointerUpOrCancel, { passive: false });
    svg.addEventListener('pointercancel', onPointerUpOrCancel, { passive: false });
    svg.addEventListener('pointerleave', onPointerUpOrCancel, { passive: false });

    // ----- Wheel zoom (desktop) anchored at cursor -----
    svg.addEventListener('wheel', (e) => {
      e.preventDefault();
      hideEraser();

      const scale = Math.pow(1.0015, -e.deltaY); // deltaY>0 => zoom out
      const anchorSVG = screenToSVG(e.clientX, e.clientY);
      viewBox = anchoredZoom(anchorSVG, scale, viewBox);

      applyViewBox();
    }, { passive: false });

    // ----- Resize handling -----
    function resizeCanvas() {
      svg.style.width  = `${window.innerWidth}px`;
      svg.style.height = `${window.innerHeight}px`;
      // Update cached pixel scale (dependent on clientWidth/clientHeight)
      pxScaleX = viewBox.w / svg.clientWidth;
      pxScaleY = viewBox.h / svg.clientHeight;
    }
    window.addEventListener('resize', () => {
      resizeCanvas();
      applyViewBox();
    });
    resizeCanvas();
    applyViewBox();

    // ----- Prevent default native pinch (Safari iOS) -----
    document.addEventListener('gesturestart', (e)=> e.preventDefault());
    document.addEventListener('gesturechange',(e)=> e.preventDefault());
    document.addEventListener('gestureend',   (e)=> e.preventDefault());
  })();
  </script>
</body>
</html>
